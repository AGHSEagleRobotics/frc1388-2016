// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "AutonomousCommand.h"

#define DISTANCE_TO_OBSTACLE 81.0
#define DISTANCE_CROSS_TO_ALIGNMENT 217.0
#define DISTANCE_GOAL_ALIGNMENT 70
#define DISTANCE_BETWEEN_OBSTACLES 50
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand() {
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
     // Add Commands here:
    // e.g. AddSequential(new Command1());
    //      AddSequential(new Command2());
    // these will run in order.

    // To run multiple commands at the same time,
    // use AddParallel()
    // e.g. AddParallel(new Command1());
    //      AddSequential(new Command2());
    // Command1 and Command2 will run in parallel.

    // A command group will require all of the subsystems that each member
    // would require.
    // e.g. if Command1 requires chassis, and Command2 requires arm,
    // a CommandGroup containing them would require both the chassis and the
    // arm.
              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
                      // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
	positionDial = RobotMap::driveTrainPositionSetter->GetValue();
	autonDial = RobotMap::driveTrainAutonDial->GetValue();

	switch (autonDial){
	case 0: // DO NOTHING
		break;
	case 1: // APPROACH
		AddSequential(new AutonDrive(DISTANCE_TO_OBSTACLE));
		break;
	case 2: // CROSS
		AlignToGoal();
		break;
	}

 }

void AutonomousCommand::AlignToGoal(){

	AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT));

	CorrectError();

	switch (positionDial){ //TODO MAKE DEFINES FOR DISTANCES TO DRIVE
	case 0: //LEFTMOST
		AddSequential(new AutonTurn(90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
		AddSequential(new AutonTurn(-90));
		break;
	case 1:
		break;
	case 2:
		AddSequential(new AutonTurn(-90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
		AddSequential(new AutonTurn(90));
		break;
	case 3:
		AddSequential(new AutonTurn(-90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 2));
		AddSequential(new AutonTurn(90));
		break;
	case 4: //RIGHTMOST
		AddSequential(new AutonTurn(-90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 3));
		AddSequential(new AutonTurn(90));
		break;
	}

	AddSequential(new AutonDrive(DISTANCE_GOAL_ALIGNMENT));
}

void AutonomousCommand::CorrectError(){

	int gyroPos = RobotMap::driveTraindriveGyro;

	gyroPos %= 360;

	if(gyroPos == 0)
		return;

	if(gyroPos <= 180)
		AddSequential(new AutonTurn(-1 * gyroPos)); return;

	AddSequential(new AutonTurn(360 - gyroPos));

}
