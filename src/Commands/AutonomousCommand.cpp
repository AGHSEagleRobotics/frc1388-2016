// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

//distance for center of robot to align with left low-goal from alignment line @ Pos 1

#include "AutonomousCommand.h"
#include "../Commands/AutonTurn.h"
#include "../Commands/AutonDrive.h"

#define DISTANCE_TO_OBSTACLE 81.0
#define DISTANCE_CROSS_TO_ALIGNMENT 217.0
#define DISTANCE_GOAL_ALIGNMENT 70.0
#define DISTANCE_BETWEEN_OBSTACLES 50.0
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time

// Called repeatedly when this Command is scheduled to run


// Make this return true when this Command no longer needs to run execute()
    // would require.
    // e.g. if Command1 requires chassis, and Command2 requires arm,
    // a CommandGroup containing them would require both the chassis and the
    // arm.
              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
                      // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
	positionDial = RobotMap::driveTrainPositionSetter->GetValue();
	autonDial = RobotMap::driveTrainAutonDial->GetValue();

	switch (autonDial){
	case 0: // DO NOTHING
		break;
	case 1: // APPROACH
		AddSequential(new AutonDrive(DISTANCE_TO_OBSTACLE));
		break;
	case 2: // CROSS
		AlignToGoal();
		break;
}

 }
// Called once after isFinished returns true
void AutonomousCommand::AlignToGoal(){

	AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT));

	CorrectError();

	switch (positionDial){ //TODO MAKE DEFINES FOR DISTANCES TO DRIVE
	case 0: //LEFTMOST
		AddSequential(new AutonTurn(90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
		AddSequential(new AutonTurn(-90));
		break;
	case 1:
		break;
	case 2:
		AddSequential(new AutonTurn(-90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
		AddSequential(new AutonTurn(90));
		break;
	case 3:
		AddSequential(new AutonTurn(-90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 2));
		AddSequential(new AutonTurn(90));
		break;
	case 4: //RIGHTMOST
		AddSequential(new AutonTurn(-90));
		AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 3));
		AddSequential(new AutonTurn(90));
		break;
}

	AddSequential(new AutonDrive(DISTANCE_GOAL_ALIGNMENT));
}
// Called when another command which requires one or more of the same
void AutonomousCommand::CorrectError(){
// subsystems is scheduled to run
	int gyroPos = RobotMap::driveTraindriveGyro->GetAngle();

	gyroPos %= 360;

	if(gyroPos == 0)
		return;

	if(gyroPos <= 180)
		AddSequential(new AutonTurn(-1 * gyroPos)); return;

	AddSequential(new AutonTurn(360 - gyroPos));

}
