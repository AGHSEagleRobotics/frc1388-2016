// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "AutonomousCommand.h"
#include "../Commands/FlapperHighSetpoint.h"
#include "../Commands/MoveFlapper.h"
#include "../Commands/AutonTurn.h"
#include "../Commands/AutonDrive.h"
#include "../Commands/AutonMoveFlapper.h"

#define DISTANCE_TO_OBSTACLE 81.0
#define DISTANCE_TO_MANIPULATE_OBSTACLE 84.0

#define DISTANCE_CROSS_TO_ALIGNMENT 217.0

#define DISTANCE_GOAL_ALIGNMENT_LEFT 70.0
#define DISTANCE_GOAL_ALIGNMENT_RIGHT 119.0 //NOT ACTUAL NUMBER, PLACEHOLDER

#define DISTANCE_BETWEEN_OBSTACLES 50.0

#define DEGREES_LIFT_PORTCULLIS -70.0

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand() {
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

     // Add Commands here:
    // e.g. AddSequential(new Command1());
    //      AddSequential(new Command2());
    // these will run in order.

    // To run multiple commands at the same time,
    // use AddParallel()
    // e.g. AddParallel(new Command1());
    //      AddSequential(new Command2());
    // Command1 and Command2 will run in parallel.

    // A command group will require all of the subsystems that each member
    // would require.
    // e.g. if Command1 requires chassis, and Command2 requires arm,
    // a CommandGroup containing them would require both the chassis and the
    // arm.
              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
                      // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
	RobotMap::driveTraindriveGyro->Reset();

	positionDial = RobotMap::driveTrainPositionSetter->GetValue();
	autonDial = RobotMap::driveTrainAutonDial->GetValue();

	obstacle = SmartDashboard::GetNumber("Opposing Obstacle", 0);

	switch (autonDial){

	case 0: // DO NOTHING
		break;
	case 1: // APPROACH
		AddSequential(new AutonDrive(DISTANCE_TO_OBSTACLE));
		break;
	case 2: // CROSS & AIM WITH NO FLAPPER
		CrossNoFlapper();
		Aim();
		break;
	case 3: // CROSS & AIM WITH FLAPPER
		CrossWithFlapper();
		Aim();
		break;
		//TODO account for obstacles requiring flapper
	case 4: // CROSS NO FLAPPER
		CrossNoFlapper();
		break;
	case 5: // CROSS WITH FLAPPER
		CrossWithFlapper();
		break;
	}

 }

void AutonomousCommand::CorrectError(int fieldPos){

	int toAlign;

	if(fieldPos >= 2 && fieldPos <= 4){
		toAlign = 270;

	}else if(fieldPos == 1){
		toAlign = 0;

	}else if(fieldPos == 0){
		toAlign = 90;
	}

	int gyroPos = RobotMap::driveTraindriveGyro->GetAngle();

	gyroPos %= 360;

	if(360 - gyroPos <= toAlign){
		AddSequential(new AutonTurn(-1 * (gyroPos - toAlign)));
		//TURN LEFT
	}else{
		AddSequential(new AutonTurn(toAlign - gyroPos));
		//TURN RIGHT
	}

}

void AutonomousCommand::Aim(){

	AlignToGoal(SmartDashboard::GetBoolean("Target Right Goal", false));

}

void AutonomousCommand::CrossNoFlapper(){

	AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT));

	CorrectError(positionDial);

}

void AutonomousCommand::CrossWithFlapper(){

	switch(obstacle){

	case 0 /*Portcullis*/:
		AddSequential(new AutonDrive(DISTANCE_TO_MANIPULATE_OBSTACLE));
		AddSequential(new AutonMoveFlapper(-70));
		AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT - DISTANCE_TO_MANIPULATE_OBSTACLE));

		break;
	case 1 /*Drawbridge*/:
		//set flapper to top
		AddSequential(new AutonDrive(DISTANCE_TO_MANIPULATE_OBSTACLE));
		AddSequential(new AutonMoveFlapper(50));
		AddSequential(new AutonDrive(-10)); //To pull back Drawbridge
		AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT - DISTANCE_TO_MANIPULATE_OBSTACLE + 10));

		break;
	case 2 /*Sally Port*/:
		//set flapper to top
		AddSequential(new AutonDrive(DISTANCE_TO_MANIPULATE_OBSTACLE));
		AddSequential(new AutonMoveFlapper(80));
		AddSequential(new AutonDrive(-10)); //To pull back Sally Port
		AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT - DISTANCE_TO_MANIPULATE_OBSTACLE + 10));

		break;
	}

	//DRIVE ACROSS OBSTACLE

	CorrectError(positionDial);

}

void AutonomousCommand::AlignToGoal(bool goForLeft){

	if(goForLeft == true){

		switch (positionDial){

		case 0: //LEFTMOST
			AddSequential(new AutonTurn(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
			AddSequential(new AutonTurn(-90));
			break;
		case 1:
			break;
		case 2:
			AddSequential(new AutonTurn(-90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
			AddSequential(new AutonTurn(90));
			break;
		case 3:
			AddSequential(new AutonTurn(-90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 2));
			AddSequential(new AutonTurn(90));
			break;
		case 4: //RIGHTMOST
			AddSequential(new AutonTurn(-90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 3));
			AddSequential(new AutonTurn(90));
			break;
		}

		AddSequential(new AutonDrive(DISTANCE_GOAL_ALIGNMENT_LEFT));
		AddSequential(new AutonTurn(-60));

	}else{

		switch(positionDial){

		case 0:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 4));
			AddSequential(new AutonDrive(-90));
			break;
		case 1:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 3));
			AddSequential(new AutonDrive(-90));
			break;
		case 2:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 2));
			AddSequential(new AutonDrive(-90));
			break;
		case 3:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
			AddSequential(new AutonDrive(-90));
			break;
		case 4:
			break;
		}

		AddSequential(new AutonDrive(DISTANCE_GOAL_ALIGNMENT_RIGHT));
		AddSequential(new AutonTurn(-60));
	}
}
