// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "AutonomousCommand.h"
#include "../Commands/FlapperHighSetpoint.h"
#include "../Commands/MoveFlapper.h"
#include "../Commands/AutonTurn.h"
#include "../Commands/AutonDrive.h"
#include "../Commands/AutonMoveFlapper.h"

#define DISTANCE_TO_OBSTACLE 32.0
#define DISTANCE_TO_MANIPULATE_OBSTACLE 84.0

#define DISTANCE_CROSS_TO_ALIGNMENT 217.0

#define DISTANCE_GOAL_ALIGNMENT_LEFT 70.0
#define DISTANCE_GOAL_ALIGNMENT_RIGHT 70.0 //FIXME NOT ACTUAL NUMBER, PLACEHOLDER

#define DISTANCE_BETWEEN_OBSTACLES 50.0

#define DEGREES_LIFT_PORTCULLIS -70.0

#define DISTANCE_TO_CORRECT_ACCEL 3.0

#define ACCEL_THRESHOLD 0.1
//TODO this is just an estimation, get real value

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand() {
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

     // Add Commands here:
    // e.g. AddSequential(new Command1());
    //      AddSequential(new Command2());
    // these will run in order.

    // To run multiple commands at the same time,
    // use AddParallel()
    // e.g. AddParallel(new Command1());
    //      AddSequential(new Command2());
    // Command1 and Command2 will run in parallel.

    // A command group will require all of the subsystems that each member
    // would require.
    // e.g. if Command1 requires chassis, and Command2 requires arm,
    // a CommandGroup containing them would require both the chassis and the
    // arm.
              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
                      // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS

	positionDial = SmartDashboard::GetNumber("Position", 0.0);
	autonDial = SmartDashboard::GetNumber("Autonomous Decision", 1.0);

	obstacle = SmartDashboard::GetNumber("Opposing Obstacle", 0.0);

	printf("TEST3 \n");

	printf("TEST1 \n");

	RobotMap::driveTraindriveGyro->Reset();

//	positionDial = RobotMap::driveTrainPositionSetter->GetValue();
//	autonDial = RobotMap::driveTrainAutonDial->GetValue();

	printf("TEST2 \n");

	printf("TEST3 \n");

	switch ((int) autonDial){

	case 0: // DO NOTHING
		printf("Case 0 \n");
		break;
	case 1: // APPROACH
		printf("Case 1 \n");
		AddSequential(new AutonDrive(DISTANCE_TO_OBSTACLE));
		break;
	case 2: // CROSS & AIM WITH NO FLAPPER
		printf("Case 2 \n");
		CrossNoFlapper();
		Aim();
		break;
	case 3: // CROSS & AIM WITH FLAPPER
		printf("Case 3 \n");
		CrossWithFlapper();
		Aim();
		break;
	case 4: // CROSS NO FLAPPER
		printf("Case 4 \n");
		CrossNoFlapper();
		break;
	case 5: // CROSS WITH FLAPPER
		printf("Case 5 \n ");
		CrossWithFlapper();
		break;
	default:
		printf("case %f, %d \n",autonDial, (int)autonDial  );
		break;
	}

 }

bool AutonomousCommand::CheckAccelerometer(){
	int toAdd = 0;
	std::array<float, 20> accelHist;

	if(toAdd < 20){
		toAdd++;
	}else{
		toAdd = 0;
	}

	accelHist.at(toAdd) = fabs(RobotMap::driveTrainAccelerometer->GetZ() - 1);

	if(!accelHist.size() == accelHist.max_size()){
		return false;
	}

	int valueAvg = 0;

	for(int value : accelHist){
		valueAvg += value;
	}

	valueAvg = valueAvg / 20;

	if(valueAvg <= ACCEL_THRESHOLD){
		return true;
	}

    return false;
}

void AutonomousCommand::CorrectError(int fieldPos){

	int toAlign;

	if(fieldPos >= 2 && fieldPos <= 4){
		toAlign = 270;

	}else if(fieldPos == 1){
		toAlign = 0;

	}else if(fieldPos == 0){
		toAlign = 90;
	}

	int gyroPos = RobotMap::driveTraindriveGyro->GetAngle();

	gyroPos %= 360;

	if(360 - gyroPos <= toAlign){
		AddSequential(new AutonTurn(-1 * (gyroPos - toAlign)));
		//TURN LEFT
	}else{
		AddSequential(new AutonTurn(toAlign - gyroPos));
		//TURN RIGHT
	}

}

void AutonomousCommand::Aim(){

	AlignToGoal(SmartDashboard::GetBoolean("Target Right Goal", false));

}

void AutonomousCommand::CrossNoFlapper(){

	AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT));

	while(CheckAccelerometer() == false){
		AddSequential(new AutonDrive(DISTANCE_TO_CORRECT_ACCEL));
	}

	CorrectError(positionDial);

}

void AutonomousCommand::CrossWithFlapper(){

	switch((int) obstacle){

	case 0 /*Portcullis*/:
		AddSequential(new AutonDrive(DISTANCE_TO_MANIPULATE_OBSTACLE));

		//TODO utilize if Encoder comes into play

//		AddSequential(new AutonMoveFlapper(-70));
		AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT - DISTANCE_TO_MANIPULATE_OBSTACLE));

		break;
	case 1 /*Drawbridge*/:
		//set flapper to top
		AddSequential(new AutonDrive(DISTANCE_TO_MANIPULATE_OBSTACLE));
//		AddSequential(new AutonMoveFlapper(50));
//		AddSequential(new AutonDrive(-10)); //To pull back Drawbridge
		AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT - DISTANCE_TO_MANIPULATE_OBSTACLE + 10));

		break;
	case 2 /*Sally Port*/:
		//set flapper to top
		AddSequential(new AutonDrive(DISTANCE_TO_MANIPULATE_OBSTACLE));
//		AddSequential(new AutonMoveFlapper(80));
//		AddSequential(new AutonDrive(-10)); //To pull back Sally Port
//	    AddSequential(new AutonTurn(360));  //To rotate around the robot
		AddSequential(new AutonDrive(DISTANCE_CROSS_TO_ALIGNMENT - DISTANCE_TO_MANIPULATE_OBSTACLE + 10));

		break;
	default:
		break;
	}

	//DRIVE ACROSS OBSTACLE

	while(CheckAccelerometer() == false){
		AddSequential(new AutonDrive(DISTANCE_TO_CORRECT_ACCEL));
	}

	CorrectError(positionDial);

}

void AutonomousCommand::AlignToGoal(bool goForLeft){

	if(goForLeft == true){

		switch ((int) positionDial){

		case 0: //LEFTMOST
			AddSequential(new AutonTurn(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
			AddSequential(new AutonTurn(-90));
			break;
		case 1:
			break;
		case 2:
			AddSequential(new AutonTurn(-90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
			AddSequential(new AutonTurn(90));
			break;
		case 3:
			AddSequential(new AutonTurn(-90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 2));
			AddSequential(new AutonTurn(90));
			break;
		case 4: //RIGHTMOST
			AddSequential(new AutonTurn(-90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 3));
			AddSequential(new AutonTurn(90));
			break;
		default:
			break;
		}

		AddSequential(new AutonDrive(DISTANCE_GOAL_ALIGNMENT_LEFT));
		AddSequential(new AutonTurn(60));

	}else{

		switch((int) positionDial){

		case 0:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 4));
			AddSequential(new AutonDrive(-90));
			break;
		case 1:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 3));
			AddSequential(new AutonDrive(-90));
			break;
		case 2:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES * 2));
			AddSequential(new AutonDrive(-90));
			break;
		case 3:
			AddSequential(new AutonDrive(90));
			AddSequential(new AutonDrive(DISTANCE_BETWEEN_OBSTACLES));
			AddSequential(new AutonDrive(-90));
			break;
		case 4:
			break;
		default:
			break;
		}

		AddSequential(new AutonDrive(DISTANCE_GOAL_ALIGNMENT_RIGHT));
		AddSequential(new AutonTurn(-60));
	}
}
